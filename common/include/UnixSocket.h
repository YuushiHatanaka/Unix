//==============================================================================
// UNIXソケットクラスヘッダ
//==============================================================================
#ifndef _UnixSocket_H_                      // 二重インクルード防止
#define _UnixSocket_H_                      // 二重インクルード防止

//==============================================================================
// インクルードファイル
//==============================================================================
#include "Exception.h"
#include "Socket.h"
#include <sys/un.h>

//==============================================================================
// クラス定義
//==============================================================================
//------------------------------------------------------------------------------
// UnixSocket例外クラス
//------------------------------------------------------------------------------
class UnixSocketException : public Exception
{
public:
    //--------------------------------------------------------------------------
    // コンストラクタ
    //--------------------------------------------------------------------------
    UnixSocketException(std::string format, ...)
        : Exception()
    {
        // メッセージ生成
        va_list ap;
        va_start(ap, format);
        this->SetMessage(format, ap);
        va_end(ap);
    };
};

//------------------------------------------------------------------------------
// UnixSocketクラス
//------------------------------------------------------------------------------
class UnixSocket : public Socket
{
protected:
    struct sockaddr_un m_pathaddr;          // PATHアドレス
    socklen_t m_pathaddr_length;            // ソケットアドレスサイズ
    std::string m_path;                     // ソケットパス

public:
    //--------------------------------------------------------------------------
    // コンストラクタ
    //--------------------------------------------------------------------------
    UnixSocket(std::string path) : Socket()
    {
        // PATH設定
        this->SetPath(path);
    }

    //--------------------------------------------------------------------------
    // コンストラクタ
    //--------------------------------------------------------------------------
    UnixSocket(int socket) : Socket(socket)
    {
    }

    //--------------------------------------------------------------------------
    // コンストラクタ
    //--------------------------------------------------------------------------
    UnixSocket(int socket, std::string path) : Socket(socket)
    {
        // PATH設定
        this->SetPath(path);
    }

    //--------------------------------------------------------------------------
    // コンストラクタ
    //--------------------------------------------------------------------------
    UnixSocket(UnixSocket& socket) : Socket(socket)
    {
        // コピー
        this->m_pathaddr = socket.m_pathaddr;
        this->m_pathaddr_length = socket.m_pathaddr_length;
        this->m_path = socket.m_path;
    }

    //--------------------------------------------------------------------------
    // デストラクタ
    //--------------------------------------------------------------------------
    virtual ~UnixSocket()
    {
    }

    //--------------------------------------------------------------------------
    // 生成
    //--------------------------------------------------------------------------
    bool Create()
    {
        // 親クラスのCreateメソッドを呼び出し、結果を返却
        return Socket::Create(AF_UNIX, SOCK_STREAM, 0);
    }

    //--------------------------------------------------------------------------
    // PATH設定
    //--------------------------------------------------------------------------
    void SetPath(std::string path)
    {
        memset(&(this->m_pathaddr), 0x00, sizeof(this->m_pathaddr));
        this->m_pathaddr.sun_family = AF_UNIX;
        strcpy(this->m_pathaddr.sun_path, path.c_str());
        this->m_path = path;
    }

    //--------------------------------------------------------------------------
    // PATH取得
    //--------------------------------------------------------------------------
    std::string GetPath()
    {
        return this->m_path;
    }

    //--------------------------------------------------------------------------
    // 名前付与
    //--------------------------------------------------------------------------
    bool Bind()
    {
        // 名前付与
        if(bind(this->m_socket, (struct sockaddr*)&(this->m_pathaddr), sizeof(this->m_pathaddr)) != 0)
        {
            // エラー番号設定
            this->m_errno = errno;

            // 異常終了
            return false;
        }

        // 正常終了
        return true;
    }

    //--------------------------------------------------------------------------
    // 接続要求受付
    //--------------------------------------------------------------------------
    int Accept()
    {
        // 接続要求受付
        int _socket = accept(this->m_socket, (struct sockaddr*)&(this->m_pathaddr), &(this->m_pathaddr_length));

        // 結果判定
        if(_socket < 0)
        {
            // エラー番号設定
            this->m_errno = errno;

            // 異常終了
            return _socket;
        }

        // 正常終了
        return _socket;
    }

    //--------------------------------------------------------------------------
    // 接続
    //--------------------------------------------------------------------------
    bool Connect()
    {
        // 接続
        if(connect(this->m_socket, (struct sockaddr*)&(this->m_pathaddr), sizeof(this->m_pathaddr)) != 0)
        {
            // エラー番号設定
            this->m_errno = errno;

            // 異常終了
            return false;
        }

        // 正常終了
        return true;
    }

    //--------------------------------------------------------------------------
    // ソケットファイル削除
    //--------------------------------------------------------------------------
    bool Unlink()
    {
        // ソケットファイル削除
        if(unlink(this->m_pathaddr.sun_path) != 0)
        {
            // エラー番号設定
            this->m_errno = errno;

            // 異常終了
            return false;
        }

        // 正常終了
        return true;
    }
};
#endif                                      // 二重インクルード防止
